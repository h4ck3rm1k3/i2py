#!/usr/bin/env python

# 
#  Copyright (C) 2005 Christopher J. Stawarz <chris@pseudogreen.org>
# 
#  This file is part of i2py.
# 
#  i2py is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
#  i2py is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with i2py; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

"""
This script converts IDL source files to Python.  Currently, the converted file
is written to the standard output.  Usage is

   $ idl2python [-d] [--rcfile=<rcfilename>] <filename>

If the '-d' option is given, the script dumps the parse tree as IDL code.  This
is useful for checking whether the parsing was successful.

If '--rcfile' is given, the specified file must contain Python source code that
defines procedure and function mappings with add_proc() and add_func().  (See
the file i2py/maps.py for examples.)  If '--rcfile' is not given, the script
will look for a file named 'i2pyrc' or 'i2pyrc.py' in the current directory.
If such a file exists, it will be used as the configuration file.
"""

import sys
import getopt
import fileinput
import os.path

from i2py.parser import parse
import i2py.error as error
from i2py.fmap import add_proc, add_func

default_rcfile = 'i2pyrc'
rcfile = None
debug = False

opts, args = getopt.getopt(sys.argv[1:], 'd', ['rcfile='])
for o, v in opts:
   if o == '--rcfile':
      rcfile = v
   if o == '-d':
      debug = True

if not rcfile:
   for f in [default_rcfile, default_rcfile + '.py']:
      if os.path.isfile(f):
         rcfile = f
	 break
if rcfile:
   execfile(rcfile)

exit_stat = 0

def process_file(input):
   global exit_stat

   input = ''.join(input)
   prog = parse(input, debug=0)
   if prog:
      if debug:
         prog = str(prog).rstrip('\n')
      else:
         prog = prog.pycode().rstrip('\n')

   if error.error_occurred():
      for e in error.get_error_list():
         sys.stderr.write('%s:%s\n' % (filename, e))
      exit_stat = 1
      error.clear_error_list()
   else:
      print prog

input = []
for line in fileinput.input(args):
   if fileinput.isfirstline():
      # Process previous file
      if input:  process_file(input)

      # Start new file
      filename = fileinput.filename()
      input = [line]
   else:
      input.append(line)
else:
   if input:  process_file(input)

sys.exit(exit_stat)

